# Rust 最小可运行系统骨架（M0）

本文件把现有规划文档收敛成一个“能跑起来的 Rust 最小系统骨架”，目标是先跑通启动、认证与最小 API 契约，再逐步接入数据库与采集链路。

## 1. 目标与边界
- 目标：WSL2 本地 `cargo run -p ems-api` 可启动服务，完成登录/刷新/动态路由。
- 目标：TenantContext 全链路存在，输出 `trace_id`/`request_id`。
- 非目标：不接入 Timescale/Redis/MQTT；用户存储使用 Postgres，其余链路仍用占位实现。

## 2. 项目硬性约束（必须遵守）
以下约束来自 `SKILL.md`，属于工程契约，M0 及后续阶段均不得违反：
- 范围目标：采集/时序/实时/历史/控制/审计/告警完整链路；WSL2 一键闭环；Rust 模块化单体；多租户从第一天生效；兼容 pure-admin-thin 登录/刷新/动态路由契约。
- 非目标：多区域部署、复杂计费、全量规则引擎、全协议覆盖（优先 MQTT）、K8s 生产化落地（仅结构占位）。
- 环境依赖：所有进程运行于 WSL2；依赖 Postgres+Timescale、Redis、MQTT；`apps/ems-api` 为唯一可执行。
- 架构边界：Monorepo（apps + crates + web/admin）；`domain` 无依赖，`api-contract` 不依赖 `storage/web`；业务模块只依赖 `domain/api-contract`；`ems-api` 仅装配与启动。
- 多租户不变量：每个请求/任务携带 `TenantContext`；`tenant_id` 禁止出现在 URL；`project_id` 出现在 URL 时必须校验归属。
- 数据与控制流：采集链路 `Source → RawEvent → normalize → PointValue → pipeline → Timescale/Redis`；控制链路 `API → auth → command → dispatcher → receipt → audit/event`。
- 实现规范：handler 禁止直接写 SQL，统一走 `storage` 层；每请求输出 `trace_id/request_id`；关键链路结构化日志。
- 完成标准：每个模块提供 `USAGE.md` 与最小示例；至少一类测试并通过；注释与模块文档在实现完成后补充。
- 行为准则：优先“能跑/可测/可演进”，禁止过度抽象与超前复杂设计。

## 3. 最小目录结构
```
apps/
  ems-api/                 # 唯一可执行
crates/
  core/
    domain/                # 领域实体与不变量（无依赖）
    api-contract/          # DTO/OpenAPI/ErrorCode
  capability/
    auth/                  # JWT/RBAC，输出 TenantContext
    storage/               # 存储 trait 与内存实现
    telemetry/             # tracing/request_id/trace_id
    config/                # 环境变量加载
```

## 4. 依赖方向硬规则（必须）
- `domain` 无依赖。
- `api-contract` 不依赖 `storage`/`web`。
- 业务模块只依赖 `domain`/`api-contract`（和必要 trait）。
- `ems-api` 负责装配与启动，其他 crate 禁止反向依赖 `ems-api`。

## 5. 模块职责（最小实现）
- `core/domain`
  - `TenantId`/`ProjectId`/`UserId` 等 ID 新类型。
  - `TenantContext { tenant_id, user_id, roles, permissions, project_scope }`。
- `core/api-contract`
  - `ApiResponse<T>`、`ErrorCode`。
  - `LoginRequest`/`LoginResponse`、`RefreshTokenRequest`/`RefreshTokenResponse`。
  - `AsyncRoute` DTO（兼容 pure-admin-thin）。
- `capability/auth`
  - `AuthService`：用户名/密码校验（内存用户表）。
  - `JwtManager`：生成/校验 access/refresh。
  - `TenantContext` 提取（从 JWT）。
- `capability/storage`
  - `UserStore`、`PermissionStore` 等 trait。
  - `InMemoryStore`：仅满足登录/权限查询。
- `capability/telemetry`
  - 生成 `request_id`/`trace_id` 并注入日志。
- `capability/config`
  - 读取环境变量（含默认值与必填校验）。
- `apps/ems-api`
  - HTTP 路由与 DI 装配。
  - handler 禁止直接写 SQL，统一走 `storage` trait。

## 6. 运行配置（最小集）
建议环境变量：
- `EMS_DATABASE_URL`：Postgres 连接串（必填）。
- `EMS_JWT_SECRET`：JWT 密钥（必填）。
- `EMS_JWT_ACCESS_TTL_SECONDS`：access token 过期秒数（必填）。
- `EMS_JWT_REFRESH_TTL_SECONDS`：refresh token 过期秒数（必填）。
- `EMS_HTTP_ADDR`：监听地址（默认 `127.0.0.1:8080`）。

## 7. 最小 API（可运行）
- `POST /login`（兼容 `/api/login`）
- `POST /refresh-token`（兼容 `/api/refresh-token`）
- `GET /get-async-routes`（兼容 `/api/get-async-routes`）
- `GET /health`（可选，便于本地探活）

### 登录示例
```bash
curl -sS -X POST http://localhost:8080/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"admin123"}'
```

## 8. 运行方式（M0）
```bash
scripts/db-init.sh
cargo build
cargo run -p ems-api
```

## 9. M0 验收清单
- 服务能启动并输出 `request_id/trace_id`。
- migrations/seed 可执行，默认账号可登录。
- `/api/login` 返回 access/refresh token。
- `/api/refresh-token` 可刷新 token。
- `/api/get-async-routes` 返回路由结构。
- 所有 handler 都能获取 `TenantContext`（不直接写 SQL）。

## 10. 后续落地（从 M0 到 M1+）
- 接入 Timescale/Redis/MQTT 与完整采集链路。
 - 补充 docker-compose 依赖编排。
- 接入项目/网关/设备/点位 CRUD。
- 接入 MQTT 采集链路与 Timescale 写入。
